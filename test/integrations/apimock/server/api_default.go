/*
 * Firefox Guardian API
 *
 * API to manage Guardian accounts, devices and servers
 *
 * API version: 0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"crypto/sha512"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/gorilla/mux"
	"github.com/mozilla-services/guardian-vpn-windows/test/integrations/apimock/server/models"
)

var subscriptionStatus = true
var devices = []models.GuardianDevice{
	models.GuardianDevice{
		Name:        "Windows-4242",
		Pubkey:      "123456",
		Ipv4Address: "10.99.0.1/32",
		Ipv6Address: "fc00:bbbb:bbbb:bb01::1/128",
		CreatedAt:   "2019-08-01T10:22:16.853Z",
	},
	models.GuardianDevice{
		Name:        "Android-2424",
		Pubkey:      "987654",
		Ipv4Address: "10.99.0.1/32",
		Ipv6Address: "fc00:bbbb:bbbb:bb01::1/128",
		CreatedAt:   "2019-08-01T10:22:16.853Z",
	},
}
var subcriptionVpn = models.AccountDetailsSubscriptionsVpn{
	Active:    subscriptionStatus,
	CreatedAt: "2019-08-01T10:22:16.853Z",
	RenewsOn:  "2019-08-01T10:22:16.853Z",
}
var accountDetailsSubscriptions = models.AccountDetailsSubscriptions{
	Vpn: subcriptionVpn,
}
var accountDetails = models.AccountDetails{
	Email:         "johndoe@example.com",
	DisplayName:   "John Doe",
	Avatar:        "https://example.com/avatar.jpg",
	Subscriptions: accountDetailsSubscriptions,
	MaxDevices:    5,
}
var expiredAccountDetails = models.ErrorSchema{
	Code:  401,
	Errno: 120,
	Error: "User doesn't have an active subscription",
}

// ApiV1VpnAccountGet - Account Information
func (router *Router) ApiV1VpnAccountGet(w http.ResponseWriter, r *http.Request) {
	if subscriptionStatus {
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)
		accountDetails.Devices = devices
		accountDetails.Subscriptions.Vpn.Active = subscriptionStatus

		js, err := json.Marshal(accountDetails)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Write(js)
	} else {
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusUnauthorized)
		js, err := json.Marshal(expiredAccountDetails)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Write(js)
	}

}

// ApiV1VpnDevicePost - Add Device
func (router *Router) ApiV1VpnDevicePost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	decoder := json.NewDecoder(r.Body)
	var t models.GuardianDevice
	err := decoder.Decode(&t)

	if err != nil {
		panic(err)
	}
	allowedIP, _ := router.wg.AddClient(t.Pubkey)
	var device = models.GuardianDevice{
		Name:        t.Name,
		Pubkey:      t.Pubkey,
		Ipv4Address: allowedIP,
		Ipv6Address: "fc00:bbbb:bbbb:bb01::1/128",
		CreatedAt:   "2019-08-01T10:22:16.853Z",
	}
	devices = append(devices, device)
	js, err := json.Marshal(device)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Write(js)
}

// ApiV1VpnDevicePubkeyDelete - Remove Device
func (router *Router) ApiV1VpnDevicePubkeyDelete(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	pubKey := vars["pubkey"]

	var newDevices []models.GuardianDevice
	for _, device := range devices {
		if device.Pubkey != pubKey {
			newDevices = append(newDevices, device)
		}
	}
	devices = newDevices
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNoContent)
}

// ApiV1VpnLoginPost - Token-based authentication flow.
func (router *Router) ApiV1VpnLoginPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	var loginResponse = models.LoginResponse{
		LoginUrl:        "https://guardian-dev.herokuapp.com/oauth/client/login/token-1234567890",
		VerificationUrl: "http://localhost:8080/v1/vpn/login/verify/token-1234567890",
		ExpiresOn:       "2099-08-01T10:22:16.853Z",
		PollInterval:    20,
	}

	js, err := json.Marshal(loginResponse)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.Write(js)
}

// ApiV1VpnServersGet - List Servers
func (router *Router) ApiV1VpnServersGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	ip, listenPort, err := router.wg.Endpoint()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	var countries = []models.Country{
		models.Country{
			Name: "Australia",
			Code: "au",
			Cities: []models.City{
				models.City{
					Name:      "Melbourne",
					Code:      "mel",
					Latitude:  -37.815018,
					Longitude: 144.946014,
					Servers: []models.Server{
						models.Server{
							Hostname:         "au3-wireguard",
							Ipv4AddrIn:       ip,
							Weight:           100,
							IncludeInCountry: true,
							PublicKey:        router.wg.PublicKey(),
							PortRanges: [][]int{
								[]int{
									int(listenPort),
									int(listenPort),
								},
							},
							Ipv4Gateway: router.wg.Gateway(),
							Ipv6Gateway: "fc00:bbbb:bbbb:bb01::1",
						},
					},
				},
			},
		},
	}
	var guardianServers = models.GuardianServer{
		Countries: countries,
	}

	js, err := json.Marshal(guardianServers)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.Write(js)
}

// ApiV1VpnVersionsGet - App Versions
func (router *Router) ApiV1VpnVersionsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	var minimum = models.VersionResponse{
		Version:    "0.2a",
		ReleasedOn: "2019-08-01T10:22:16.853Z",
		Message:    "Our first real release. Get it while it's hot!",
	}
	var latest = models.VersionResponse{
		Version:    "0.4a",
		ReleasedOn: "2019-08-01T10:22:16.853Z",
		Message:    "Our first alpha release!",
	}
	var windows = models.WindowsResponse{
		Minimum: minimum,
		Latest:  latest,
	}
	var response = models.VPNVersionResponse{
		Windows: windows,
	}
	js, err := json.Marshal(response)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.Write(js)
}

// V1VpnLoginVerifyTokenGet - Check authentication status.
func (router *Router) V1VpnLoginVerifyTokenGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	vars := mux.Vars(r)
	token := vars["token"]
	accountDetails.Devices = devices
	subscriptionStatus = !strings.Contains(token, "inactive")
	accountDetails.Subscriptions.Vpn.Active = subscriptionStatus
	var response = models.VerifyTokenResponse{
		User:  accountDetails,
		Token: "verification_token_sample",
	}
	js, err := json.Marshal(response)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.Write(js)
}

func (router *Router) BalrogVersionGet(w http.ResponseWriter, r *http.Request) {
	var reqHost = r.Host
	mockMSIHashValue := getHashValue()
	stuffToSign := []byte(fmt.Sprintf(`{"version": "0.5.1.1", "url": "http://localhost:8080/downloads/vpn/FirefoxPrivateNetworkVPN.msi", "required": true, "hashFunction": "sha512", "hashValue": "%s"}`, mockMSIHashValue))
	signedStuff, err := router.chain.Sign(stuffToSign)
	if err != nil {
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintf(w, "Error: %v\n", err)
	}
	vars := mux.Vars(r)
	version := vars["version"]
	missingSignature := false
	contentSignature := ""
	switch version {
	case "0.0.0.0":
		missingSignature = true
	case "0.0.0.1":
		signedStuff[3] ^= 1
	case "0.0.0.2":
		wrongHashValue := generateHashValue("wronghash")
		stuffToSign = []byte(fmt.Sprintf(`{"version": "0.5.1.1", "url": "http://localhost:8080/downloads/vpn/FirefoxPrivateNetworkVPN.msi", "required": true, "hashFunction": "sha512", "hashValue": "%s"}`, wrongHashValue))
		signedStuff, _ = router.chain.Sign(stuffToSign)
	case "0.0.0.3":
		stuffToSign = []byte(`{"version": "0.5.1.1", "url": "http://localhost:8080/downloads/vpn/FirefoxPrivateNetworkVPN.msi", "required": true, "hashFunction": "sha512", "hashValue": ""}`)
		signedStuff, _ = router.chain.Sign(stuffToSign)
	case "0.0.0.4":
		stuffToSign = []byte(`{"version": "0.5.1.1", whatever}`)
		signedStuff, _ = router.chain.Sign(stuffToSign)
	}
	if !missingSignature {
		contentSignature = fmt.Sprintf("; p384ecdsa=%s", base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(signedStuff))
	}
	w.Header().Set("alt-svc", "Clear")
	w.Header().Set("content-security-policy", "default-src 'none'; frame-ancestors 'none'")
	w.Header().Set("content-type", "application/json")
	w.Header().Set("content-signature", fmt.Sprintf("x5u=http://%s/chains/sigtest.chain%s", reqHost, contentSignature))
	w.Write(stuffToSign)
}

func (router *Router) BalrogRootSignatureGet(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, router.chain.RootCertificateSignature)
}

func (router *Router) BalrogSigtestChainGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("content-type", "pem-certificate-chain")
	fmt.Fprintf(w, router.chain.String())
}
func (router *Router) BalrogRegenerateCertPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	decoder := json.NewDecoder(r.Body)
	var t models.BalrogCertificate
	err := decoder.Decode(&t)

	if err != nil {
		panic(err)
	}
	router.chain.Regenerate(&t)
	js, err := json.Marshal(t)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Write(js)
}

func (router *Router) UpdateSubscriptionStatusPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	decoder := json.NewDecoder(r.Body)
	var t models.AccountDetailsSubscriptionsVpn
	err := decoder.Decode(&t)

	if err != nil {
		panic(err)
	}
	subscriptionStatus = t.Active
	js, err := json.Marshal(t)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Write(js)
}

func (router *Router) DownloadMSI(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, "../mockinstaller/x64/FirefoxPrivateNetworkMockVPN.msi")
}

func getHashValue() string {
	f, err := os.Open("../mockinstaller/x64/FirefoxPrivateNetworkMockVPN.msi")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	h := sha512.New()
	if _, err := io.Copy(h, f); err != nil {
		log.Fatal(err)
	}
	return hex.EncodeToString(h.Sum(nil))
}

func generateHashValue(text string) string {
	h := sha512.New()
	h.Write([]byte(text))
	return hex.EncodeToString(h.Sum(nil))
}
